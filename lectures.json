{"undefined": [{"_id": "7452c05b-b22a-4225-8032-195939dcb820", "title": "Lecture 1", "description": "Uploaded lecture for course undefined", "video": "/uploads/7452c05b-b22a-4225-8032-195939dcb820.mp4", "transcript": " So you've looked into AI phone callers and have discovered an overwhelming amount of platforms out there and you're not quite sure which one you should choose. Which one sounds the best? Which one is the quickest? Can I write label the platform? How much does it cost? If that's you, you're a luck because in this video I compare seven AI phone call platforms by five categories. Sound, speed, cost, integrations and features. And by the end of this video, you will know exactly which platform is best for you. The seven platforms I'm comparing are Vappy, Blend, Synthflow, Retail, AI, Voice OS and Play AI. Don't worry if you haven't heard or seen these platforms before, that's exactly why I've made this video. My name is Brendan and I run in Flate AI where my team and I help businesses integrate the latest AI solutions. To get started, I'll find out which platform sounds the best and has the most support for changing how it sounds. Now I'm not going to bore you with a call from every platform because honestly, many of these platforms sound similar for this one reason. Voice call platforms act as a bridge between various systems involved in creating phone calls. One platform like OpenAI's GPT-4 handles AI responses, another such as 11 labs generates the human sounding audio and Twilio handles the phone number and phone calls. I recently created a community post and 90% of you voted that you use 11 labs for voice generation followed by PlayHT. These two platforms from my experience are the best sounding providers currently on the market and I'll demo these two providers in just a second. Five out of the seven platforms I'm reviewing have support for either 11 labs or PlayHT directly. Now unfortunately this doesn't mean all of the platforms allow you to customize the voice or upload custom voices and I'll cover why this matters in just a minute. You can go ahead and view the platform support on this graph that I'm showing on the screen now. Here is a quick demo of an 11 labs voice. Hello this is Mary from Mary's Dental. How can I assist you today? Hi my name is Brendan my truth just fell out. Hey Brandon who needs the tooth fairy when you've got us right? I can schedule an appointment for you to get that fixed. When would you like to come in? And here is a quick demo of a PlayHT voice. Hello this is Mary from Mary's Dental. How can I assist you today? Hi my name is Brendan I was just calling since one of my teeth had fallen out. I was just wondering if I could book an appointment for tomorrow morning. Hey Brendan ah sorry to hear about your tooth. Let's get that fixed up. Can I have your full name please? Sure my name is Brendan Johnson. Thanks Brendan. So a tooth falling out is never fun. Let's get you fixed up. How about we book an appointment for tomorrow morning? What time worked best for you? Vappy, retail, Synthflow, VoiceOS and PlayAI have direct support for either one of these voice providers. In addition to this we get full access to configure these voices using 11 labs or PlayHT voice configuration settings. The reason it's important to be able to change the voice settings is that not all of these voices are recorded the same. So voices can pronounce words differently and output sentences with different tones. Depending on the voice you've chosen and what you intend the voice to say you may need to tweak the voice. Blend and AI state that they are using their own voices however they are likely using a third party provider like a 11 labs or similar in the background. The downside of these platforms is that we don't get access to the custom voice settings and we can't upload specific 11 labs or PlayHT voices. 11 labs has a marketplace where people can upload their own voice clones for people to go ahead and use. Going through all these platforms the only one that actually allows to upload custom 11 labs voices and change the voice settings is Vappy.ai. So some of the best voices I find given that I'm in Australia are on the 11 labs voice library. So this just means that Vappy is the only platform where I can easily access these voices. Vappy also has an integrated dashboard for 11 labs and PlayHT voices which you can see on the screen now. This is just really helpful for quickly finding voices that might be good for your assistant. As equally important as the sound is to the realism of the call a fast responding AI caller can make or break your call. This is directly related to the sound as typically the better sounding the caller the longer the response time becomes. I've created a prompt for a lead qualification caller and I've gone ahead and created an assistant on every single platform using the exact same prompt. I've gone ahead and set the settings to open our GPT3.5 on equivalent and set the voice provider to either 11 labs or PlayHT or their default setting. For the platforms with 11 labs support I use the voice mirror across each test. I called each platform five times and went through these calls recording the delay between my questions and the responses and then I calculated an average response delay between each platform. Coming in at number one we had retail with a 1.54 second average. Number two we had PlayAI which read a 1.747 average. Number three we had Vappy which had a 1.8 second average and we had Bland at 1.9 seconds. AI at 2 seconds. Synthflow at 2.1 seconds and voice OS at 3.2 seconds. Please note that these results are based on my small sample size of data. So I do still recommend you go and test different platforms for your specific needs but these are just the results that I got from my own prompt. Here's a live call with a retail system. Hi I was just wondering if I could book an appointment for tomorrow morning. Hey there sure thing I can help you with that. Before we dive in can I get your full name please? Yeah my name is Brendan Johnson. Nice to meet you Brendan. What brings you to Mary's dental? Yeah one of my teeth that just fallen out that's all. Oh no Brendan we can't have you losing teeth left and right. Let's get that sorted out. When would you like to come in? Now that you know which platforms are the quickest and wish to choose for sound. None of these factors matter if they aren't cost efficient. Ultimately these callers are competing against an alternative sales team that can be hired to make these calls manually. There isn't a simple cost for each platform as the configuration you choose affects the callers cost. So I set a default caller across platforms are daily using a provider like a level labs or play HT utilizing GbD3.5 or an equivalent. The voice provider and AI model are the two most cost demanding parts of an AI caller. Some of the platforms require you to purchase a set amount of minutes every single month. So depending on your usage it may be cheaper to choose a platform that charges based solely on usage instead of charging a sort of one-time monthly amount. Coming in at number one the cheapest option is play AI which is only five cents per minute. This does require a monthly payment and that monthly payment is $20 per month. Coming in at number two we had nine cents a minute with planned AI that doesn't require monthly payment. We had AI at 11 cents a minute, retail AI at 12 cents a minute, VAPI at 13 cents a minute, voice OS at 13 cents a minute and then we had SINFLOW at 15 to 18 cents a minute and this does require a monthly payment and that monthly payment is around $29 a month. Play AI is the cheapest option likely because it earns the play HT platform and can provide users with lowest cost of voice possible. Sounding good, being quick and being cost efficient is great. However these calls aren't all static. We may need to book appointments, retrieve specific data or send data into a CRM system, all these calls to meet their objectives. Some of these platforms have native integrations with services like Go High Level and Zepia or others provide web hooks for you to build your own automations. SINFLOW and BLAND have the most built-in integrations out of all the platforms I've seen. They offer pre-built Zaps as well as a Zepia block that you can get access to through Zepia and this means you can configure it with thousands of different applications. Additionally they have a pre-built appointment-blowing function that works directly with Cal.com. I'd say SINFLOW and BLAND are better for beginners and no-code users. It seems they're going in the direction of ease of use. VAPI and AI follow with Go High Level, Zepia and make integrations but it's only to help you set up the web book more easily compared to pre-built automations. Overall every platform has the ability to run actions during the call. Some are just easier to set up than others. Moving on to some of the unique features of each platform. BLAND AI, SINFLOW and Retail have quite a unique feature that makes building complex voice assistance a lot easier and provides more control over the output. I'm referring to BLAND's conversational pathways, SINFLOW's workflows and retails multi-pronged agents. These are no-code visual building platforms that allow you to get a lot more depth to your assistant. Essentially you can combine multiple prompts and third basic if this is the that conditioning set predetermined messages or actions. Using this depends on your specific use case. Most of the projects we built at our agency haven't required this and we typically stick to single prompt engineering as allows us to test their system and make improvements easier but I do encourage you to try out all of these platforms to see which one you like the best. If you're looking to sell AI voice systems to other businesses you may consider white labeling the platform. If you want to integrate this into your business directly you may prefer using custom APIs to achieve the lowest cost. If this is you go ahead and book a call with my team using the link in the description. We've helped several businesses integrate AI call systems assisting in taking missed calls or completely replacing all calls entirely. Out of the seven platforms only one enables you to fully white label which is SINFLOW. SINFLOW offers an entire plan designed for agencies to white label and resell. Let me know in the comments below if you want me to do a full walk through of this plan and how you can use it. One of the most important factors in building voice assistance is ensuring they are reliable and that they perform to an accurate degree. The first step in building reliable voice call is evaluating the data that we receive and improving our prompts over time. Some platforms offer extensive testing capabilities or others provide none at all. Retail has a feature that allows you to test the system without having to call it. You can chat using the text input and then you can test the outputs. This is a feature that I wish every platform had as it allows you to rapidly test without calling the system every single time. This is also going to save on costs because we're not playing for all of those. Tulio and 11 labs of costs. Bappy has an analysis tab that you can use to get a wide range of feedback from. This is great for measuring if a call reached its call objective. You can provide a custom prompt that essentially determines if the call was a success or not. This allows us to easily detect any issues and make adjustments quickly. Once you've chosen your platform you've completed step one but now you need to know how to actually build your voice assistance. If you want to learn how to prompt AI voice callers click the video on the left and if you want to learn everything to do with building AI voice callers in two hours click the video on the right.", "course_id": "undefined"}, {"_id": "398be991-7380-40f3-8741-04d4579cf2be", "title": "Lecture 1", "description": "Uploaded lecture for course undefined", "video": "/uploads/398be991-7380-40f3-8741-04d4579cf2be.mp4", "transcript": " Web development is the best job in the world. You build on a platform with nearly 5 billion daily active users, all connected together like the neurons of a global super intelligent brain, a system that can cure disease, eliminate poverty, advance science, and stuff like that. But mostly it's used to share memes, create pair of social relationships, amplify drama, and most importantly, make tons and tons of money. If you want to get into it, you're going to need to know some stuff, like a lot of stuff. In web development 101, we'll take a look at 101 different concepts that you'll need to know when building full-stack web apps. This is the internet. It's a network of billions of machines connected together. What are you right to it like mail? No, a lot of people use it and communicate. I guess they can communicate with NBC, writers, and producers, Allison. Can you explain what internet is? It was officially born on January 1st, 1983, thanks to the establishment of the internet protocol suite, which standardize the way these computers communicate. The internet protocol is used to identify different computers on the network by assigning each one of them a unique IP address. These computers can then send data back and forth with the transmission control protocol. It breaks data into a bunch of small packets, kind of like puzzle pieces, then sends them through a bunch of physical components like fiber optic cables and modems before they're put back together by the receiving computer. You can think of the internet as hardware, but the internet is not the same thing as the web. The worldwide web is like software that sits on top of the internet, where people can access web pages with the hypertext transfer protocol. What's special about it is that it gives every page of content a uniform resource locator or URL. Humans typically use a tool called a web browser to access a URL where it can be rendered visually on their screen. The browser is called the client because it's consuming information, but on the other end of that URL there's another computer called a server. It received an HTTP request from the client, then sent a response containing the web page content. These are called HTTP messages, but more on that later. What's interesting is that every web page has a unique domain name, like fireship.io or example.com. A domain name can be registered by anyone via a registrar who's accredited by ICANN, a nonprofit responsible for overseeing namespaces on the internet. When you navigate to a domain in a browser, it gets routed through the domain name system that maps these names to an actual IP address on a server somewhere. DNS is like the phone book of the internet. Now, when you look at a web page, the actual content you see is represented by hypertext markup language. Most browsers have dev tools where you can inspect the structure of the HTML at any time. To build your own web page, you'll want a text editor like VS Code. An HTML document is just a collection of elements where an element is an opening and closing tag with some content in the middle, like a paragraph and heading. It also has elements that handle user input, like the select and input elements, which are used to build forms. In addition, elements can have one or more attributes to change their behavior. For example, an input can have a type like text or number, which the browser will render differently to collect the appropriate value. But the element that puts the hypertext in HTML is the A tag or anchor. It's a link that allows one page to navigate to a different page based on its URL. These elements are nested together in a hierarchy to form the document object model or DOM. From the root element, a web page is split into two parts. The head contains invisible content like metadata and a title. Then we have the body for the main content that the end user actually sees. The reason we wrap everything in tags is to give browsers and bots hints about the semantic meaning of the web page. This allows search engines to display results properly and also helps with accessibility for devices like screen readers that allow anybody regardless of disability to enjoy the content. My computer reads me the text. Bro, smash that like button and subscribe. One of the most common elements you'll come across is div or division to define a section of the web page. On its own, a div might not seem to do anything and currently produces this plain black and white website. That begs the question, how do we make this website look cool? The second language you'll need to learn as a web developer is cascading style sheets or CSS, which allows you to change the appearance of the HTML elements. One way to accomplish that is with an inline style, using the style attribute on an element. The style itself contains a collection of properties and values that change the appearance of the element, like we might make the background color black and the text color red. What we've created here is an inline style that will only be applied to this one element. However, CSS cascades, which means it can be applied to multiple elements at the same time, providing better code reusability. Another option is to move our code into a style tag, but to make the code work, we'll first need to define a selector so it knows which elements to target. A selector, for example, can target all of the paragraph elements on the page, but that's too broad. We can be more granular by defining a class. That style can then be applied to one or more elements with the class attribute. What's interesting though, is that we now have classes that apply different styles to the same element. CSS contains a bunch of specificity rules that determine which styles are relevant to an element in a way that's self evident and elegant, like a benevolent elephant. Most often though, we don't use style tags, but instead use an external style sheet, which is linked to the web page in the head of the document. When it comes to CSS, by far the most difficult thing to learn is layout and positioning. Think of every element like a box. The outside of that box is wrapped with padding, border, and margin. The boxes then take up space on the page from top to bottom. Some elements like heading have a display of block by default, which means they take up all available horizontal space. Other elements like image are displayed in line, which means they can line up horizontally side by side. The problem is that the default position is usually not desirable. It can be changed by customizing the position property on an element. Relative positioning allows an element to move a certain number of pixels from its normal position. Absolute positioning is similar, but the position values are relative to its nearest ancestor. And then we have fixed positioning, which will keep an element on the screen, even as the user scrolls away from it, because it's fixed to the entire viewport. Changing the position of an element is one thing, but one of the biggest challenges web developers face is creating responsive layouts. Users can access your web page from all kinds of different screens, and it should look good on all of them. CSS provides a bunch of different tools to help make this happen. One of which is media queries. A media query allows you to get information about the device that's rendering the web page, and apply different styles accordingly. But more importantly, it provides layout tools like flexbox. Applying display flex allows the parent to control the flow of the children to easily create rows and columns. For more complex layouts, display grid can be used to control multiple rows and columns at the same time. Now CSS is usually not considered a Turing Complete Programming Language on its own. However, it does have mechanisms like Calc to perform mathematical operations, and custom properties, which are like variables that you can reuse in multiple places. Vanilla CSS is rarely enough, though, and many developers choose to extend it with tools like SAS that add additional programmatic features on top of it, and that brings us to the third language you'll need to know as a web developer, JavaScript. Technically, you don't need JavaScript to build a website. However, most developers choose to use it to make the user interface more interactive. To run JavaScript code on a web page, open up a script tag, then write some JavaScript code inside of it. The browser interprets the HTML from top to bottom, and runs this code when it encounters it in the DOM. In most cases, JavaScript is written in a separate file, then referenced as the source on the script tag. Usually, it's preferred that this code runs after the DOM content has loaded, which can be accomplished with the defer attribute. JS is a big complicated programming language, which is more formally known as ECMO script and is standardized in all major browsers. There are several different ways to declare a variable, a variable that might be reassigned in the future uses the like keyword, while a variable that can't be reassigned uses const. It's a dynamically typed language, which means no type annotations are necessary. That's not always ideal, so many developers choose TypeScript as an alternative to add static typing on top of JavaScript. Now, one of the most common reasons you would use JavaScript in the first place is to handle events. Whenever the user does something on a web page, the browser emits an event that you can listen to. Like a click, mouse move, form input change, and so on. We can tap into these events using browser APIs like document, which in this case provides a method called query selector that allows us to grab an element with a CSS selector. Once we have that element set as a variable, we can then assign an event listener to it. An event listener is a function that will be called or re-executed anytime the button is clicked. The language has a variety of built-in data structures like an array to represent a collection of values, but the most fundamental data structure is the object. Also commonly called a dictionary or hash map. Anything that's not a primitive type like a string or number inherits its base functionality from the object class. It relies on a technique called prototypal inheritance, where an object can be cloned multiple times to create a chain of ancestors where the child inherits the properties and methods of its ancestors. This is different from class-based inheritance, which is kind of confusing because JavaScript also supports classes. However, these classes are just syntactic sugar for prototypal inheritance, but now we're getting a little too low level. Most developers don't ever want to have to touch the word prototype, so what we do instead is use a front-end framework, like React, View, Spelt, Angular, and so on. All of these frameworks do the same thing in a slightly different way, which is represent the UI as a tree of components. A component can encapsulate HTML, CSS, and JavaScript into a format that looks like its own custom HTML element. Most importantly, they produce declarative code that describes exactly what the UI does, and that's much easier to work with than imperative code that you would normally get with just plain vanilla JavaScript. At this point, we've taken a look at the front-end stack, but now we need to switch gears to the back end, starting with Node.js, which is a server-side runtime based on JavaScript. You can run server-side code for web applications in all kinds of different languages, but Node is the most popular because it relies on the same language as the browser. It's also based on the same V8 engine that powers the chromium browser to run code in a single threaded, non-blocking event loop. This allows Node to handle many simultaneous connections quickly and efficiently. In addition, it allows developers to share work remotely thanks to the Node Package Manager. A package is also called a module, which is just a file that contains some code with an export statement so it can be used in another file. The file can consume a module with an import statement, but now we need to think about how to deliver the actual website from the server to the client. The classic option is server-side rendering. In this approach, the client will make a Git request for a certain URL. Every request has an HTTP method, and Git means you want to retrieve data from a server, as opposed to methods like Post and Patch, where the intent is to modify data. The server receives the request, and then generates all the HTML on the server, and sends it back to the client as a response. The response contains a status code, like 200 for success, or levels 4 and 504 errors. For example, if the webpage doesn't exist, the server will return a 404 status code, which you've likely seen before as a web user. SSR is extremely popular, but in some cases, it may not be fast enough. Another approach is the single page application. With this approach, the server only renders a shell for the root URL. Then JavaScript handles the rendering for all other pages on the website. The HTML is generated almost entirely client-side in the browser. Making the website feel more like a native iOS or Android app. When the app needs more data, it still makes an HTTP request, but only requests a minimal amount of data as JSON, which is called a data interchange format that can be understood by any programming language. This can result in a great user experience. However, it can be very difficult for bots, like search engines, and social media link previews, to understand content on the page. This led to another rendering strategy called static site generation. In this case, every web page on the site is uploaded to a server in advance, allowing bots to get the information they need. A front-end JavaScript framework usually takes over to hydrate the HTML, to make it fully interactive, and behave like a single page application. Performance is extremely important, and you'll want to use tools like Lighthouse to optimize metrics like first-contentful paint and time to interactive. Now, to implement one of these patterns, most developers will use a full-stack framework, like next JS, Ruby on Rails, Larvel, and so on. They abstract away many of the more tedious things developers don't want to deal with, one of which is module bundlers, which are tools like webpack and vete that take all of your JavaScript CSS and HTML and package it in a way that can actually work in a browser. They might also provide a linter, like ESLint, to warn you when your code doesn't follow the proper style guidelines. Oh, and I almost forgot, you are definitely going to need a database to build a full-stack web application, because you need somewhere to store your data, like data about your users, but in order to get that data, you'll need to give users a way to log in via a process called user authentication. Now, before you deploy your code, you'll need to test it with a web server. There are tools like Ingenax and Apache. You create an HTTP server, but your framework will likely do this for you by serving the files on localhost, which makes your own IP address behave like a remote web server. When it comes time to deploy, you'll likely use a big cloud provider like AWS. Most apps are containerized with Docker, making them easy to scale up and down based on the amount of traffic that they receive. There are many tools out there that function as a platform as a service to manage this infrastructure for you in exchange for your money. Or, if you don't want to get locked in with a giant tech corporation, you might host your app on a decentralized blockchain with Web3. And that's about 1% of what you'll need to know to call yourself a full-stack web developer. If that seems overwhelming, don't worry too much. Almost nobody knows what the hell they're doing, and we all just use Google to figure things out on the fly. Congratulations, you just passed Web Development 101. Thanks for watching, and I will see you in the next one.", "course_id": "undefined"}, {"_id": "743b84bc-c8b9-4980-be7b-b25d01789ace", "title": "Lecture 2", "description": "Uploaded lecture for course undefined", "video": "/uploads/743b84bc-c8b9-4980-be7b-b25d01789ace.mp4", "transcript": " Web development is the best job in the world. You build on a platform with nearly 5 billion daily active users, all connected together like the neurons of a global super intelligent brain, a system that can cure disease, eliminate poverty, advance science, and stuff like that. But mostly it's used to share memes, create pair of social relationships, amplify drama, and most importantly, make tons and tons of money. If you want to get into it, you're going to need to know some stuff, like a lot of stuff. In web development 101, we'll take a look at 101 different concepts that you'll need to know when building full-stack web apps. This is the internet. It's a network of billions of machines connected together. What are you right to it like mail? No, a lot of people use it and communicate. I guess they can communicate with NBC, writers, and producers, Allison. Can you explain what internet is? It was officially born on January 1st, 1983, thanks to the establishment of the internet protocol suite, which standardize the way these computers communicate. The internet protocol is used to identify different computers on the network by assigning each one of them a unique IP address. These computers can then send data back and forth with the transmission control protocol. It breaks data into a bunch of small packets, kind of like puzzle pieces, then sends them through a bunch of physical components like fiber optic cables and modems before they're put back together by the receiving computer. You can think of the internet as hardware, but the internet is not the same thing as the web. The worldwide web is like software that sits on top of the internet, where people can access web pages with the hypertext transfer protocol. What's special about it is that it gives every page of content a uniform resource locator or URL. Humans typically use a tool called a web browser to access a URL where it can be rendered visually on their screen. The browser is called the client because it's consuming information, but on the other end of that URL there's another computer called a server. It received an HTTP request from the client, then sent a response containing the web page content. These are called HTTP messages, but more on that later. What's interesting is that every web page has a unique domain name, like fireship.io or example.com. A domain name can be registered by anyone via a registrar who's accredited by ICANN, a nonprofit responsible for overseeing namespaces on the internet. When you navigate to a domain in a browser, it gets routed through the domain name system that maps these names to an actual IP address on a server somewhere. DNS is like the phone book of the internet. Now, when you look at a web page, the actual content you see is represented by hypertext markup language. Most browsers have dev tools where you can inspect the structure of the HTML at any time. To build your own web page, you'll want a text editor like VS Code. An HTML document is just a collection of elements where an element is an opening and closing tag with some content in the middle, like a paragraph and heading. It also has elements that handle user input, like the select and input elements, which are used to build forms. In addition, elements can have one or more attributes to change their behavior. For example, an input can have a type like text or number, which the browser will render differently to collect the appropriate value. But the element that puts the hypertext in HTML is the A tag or anchor. It's a link that allows one page to navigate to a different page based on its URL. These elements are nested together in a hierarchy to form the document object model or DOM. From the root element, a web page is split into two parts. The head contains invisible content like metadata and a title. Then we have the body for the main content that the end user actually sees. The reason we wrap everything in tags is to give browsers and bots hints about the semantic meaning of the web page. This allows search engines to display results properly and also helps with accessibility for devices like screen readers that allow anybody regardless of disability to enjoy the content. My computer reads me the text. Bro, smash that like button and subscribe. One of the most common elements you'll come across is div or division to define a section of the web page. On its own, a div might not seem to do anything and currently produces this plain black and white website. That begs the question, how do we make this website look cool? The second language you'll need to learn as a web developer is cascading style sheets or CSS, which allows you to change the appearance of the HTML elements. One way to accomplish that is with an inline style, using the style attribute on an element. The style itself contains a collection of properties and values that change the appearance of the element, like we might make the background color black and the text color red. What we've created here is an inline style that will only be applied to this one element. However, CSS cascades, which means it can be applied to multiple elements at the same time, providing better code reusability. Another option is to move our code into a style tag, but to make the code work, we'll first need to define a selector so it knows which elements to target. A selector, for example, can target all of the paragraph elements on the page, but that's too broad. We can be more granular by defining a class. That style can then be applied to one or more elements with the class attribute. What's interesting though, is that we now have classes that apply different styles to the same element. CSS contains a bunch of specificity rules that determine which styles are relevant to an element in a way that's self evident and elegant, like a benevolent elephant. Most often though, we don't use style tags, but instead use an external style sheet, which is linked to the web page in the head of the document. When it comes to CSS, by far the most difficult thing to learn is layout and positioning. Think of every element like a box. The outside of that box is wrapped with padding, border, and margin. The boxes then take up space on the page from top to bottom. Some elements like heading have a display of block by default, which means they take up all available horizontal space. Other elements like image are displayed in line, which means they can line up horizontally side by side. The problem is that the default position is usually not desirable. It can be changed by customizing the position property on an element. Relative positioning allows an element to move a certain number of pixels from its normal position. Absolute positioning is similar, but the position values are relative to its nearest ancestor. And then we have fixed positioning, which will keep an element on the screen, even as the user scrolls away from it, because it's fixed to the entire viewport. Changing the position of an element is one thing, but one of the biggest challenges web developers face is creating responsive layouts. Users can access your web page from all kinds of different screens, and it should look good on all of them. CSS provides a bunch of different tools to help make this happen. One of which is media queries. A media query allows you to get information about the device that's rendering the web page, and apply different styles accordingly. But more importantly, it provides layout tools like flexbox. Applying display flex allows the parent to control the flow of the children to easily create rows and columns. For more complex layouts, display grid can be used to control multiple rows and columns at the same time. Now CSS is usually not considered a Turing Complete Programming Language on its own. However, it does have mechanisms like Calc to perform mathematical operations, and custom properties, which are like variables that you can reuse in multiple places. Vanilla CSS is rarely enough, though, and many developers choose to extend it with tools like SAS that add additional programmatic features on top of it, and that brings us to the third language you'll need to know as a web developer, JavaScript. Technically, you don't need JavaScript to build a website. However, most developers choose to use it to make the user interface more interactive. To run JavaScript code on a web page, open up a script tag, then write some JavaScript code inside of it. The browser interprets the HTML from top to bottom, and runs this code when it encounters it in the DOM. In most cases, JavaScript is written in a separate file, then referenced as the source on the script tag. Usually, it's preferred that this code runs after the DOM content has loaded, which can be accomplished with the defer attribute. JS is a big complicated programming language, which is more formally known as ECMO script and is standardized in all major browsers. There are several different ways to declare a variable, a variable that might be reassigned in the future uses the like keyword, while a variable that can't be reassigned uses const. It's a dynamically typed language, which means no type annotations are necessary. That's not always ideal, so many developers choose TypeScript as an alternative to add static typing on top of JavaScript. Now, one of the most common reasons you would use JavaScript in the first place is to handle events. Whenever the user does something on a web page, the browser emits an event that you can listen to. Like a click, mouse move, form input change, and so on. We can tap into these events using browser APIs like document, which in this case provides a method called query selector that allows us to grab an element with a CSS selector. Once we have that element set as a variable, we can then assign an event listener to it. An event listener is a function that will be called or re-executed anytime the button is clicked. The language has a variety of built-in data structures like an array to represent a collection of values, but the most fundamental data structure is the object. Also commonly called a dictionary or hash map. Anything that's not a primitive type like a string or number inherits its base functionality from the object class. It relies on a technique called prototypal inheritance, where an object can be cloned multiple times to create a chain of ancestors where the child inherits the properties and methods of its ancestors. This is different from class-based inheritance, which is kind of confusing because JavaScript also supports classes. However, these classes are just syntactic sugar for prototypal inheritance, but now we're getting a little too low level. Most developers don't ever want to have to touch the word prototype, so what we do instead is use a front-end framework, like React, View, Spelt, Angular, and so on. All of these frameworks do the same thing in a slightly different way, which is represent the UI as a tree of components. A component can encapsulate HTML, CSS, and JavaScript into a format that looks like its own custom HTML element. Most importantly, they produce declarative code that describes exactly what the UI does, and that's much easier to work with than imperative code that you would normally get with just plain vanilla JavaScript. At this point, we've taken a look at the front-end stack, but now we need to switch gears to the back end, starting with Node.js, which is a server-side runtime based on JavaScript. You can run server-side code for web applications in all kinds of different languages, but Node is the most popular because it relies on the same language as the browser. It's also based on the same V8 engine that powers the chromium browser to run code in a single threaded, non-blocking event loop. This allows Node to handle many simultaneous connections quickly and efficiently. In addition, it allows developers to share work remotely thanks to the Node Package Manager. A package is also called a module, which is just a file that contains some code with an export statement so it can be used in another file. The file can consume a module with an import statement, but now we need to think about how to deliver the actual website from the server to the client. The classic option is server-side rendering. In this approach, the client will make a Git request for a certain URL. Every request has an HTTP method, and Git means you want to retrieve data from a server, as opposed to methods like Post and Patch, where the intent is to modify data. The server receives the request, and then generates all the HTML on the server, and sends it back to the client as a response. The response contains a status code, like 200 for success, or levels 4 and 504 errors. For example, if the webpage doesn't exist, the server will return a 404 status code, which you've likely seen before as a web user. SSR is extremely popular, but in some cases, it may not be fast enough. Another approach is the single page application. With this approach, the server only renders a shell for the root URL. Then JavaScript handles the rendering for all other pages on the website. The HTML is generated almost entirely client-side in the browser. Making the website feel more like a native iOS or Android app. When the app needs more data, it still makes an HTTP request, but only requests a minimal amount of data as JSON, which is called a data interchange format that can be understood by any programming language. This can result in a great user experience. However, it can be very difficult for bots, like search engines, and social media link previews, to understand content on the page. This led to another rendering strategy called static site generation. In this case, every web page on the site is uploaded to a server in advance, allowing bots to get the information they need. A front-end JavaScript framework usually takes over to hydrate the HTML, to make it fully interactive, and behave like a single page application. Performance is extremely important, and you'll want to use tools like Lighthouse to optimize metrics like first-contentful paint and time to interactive. Now, to implement one of these patterns, most developers will use a full-stack framework, like next JS, Ruby on Rails, Larvel, and so on. They abstract away many of the more tedious things developers don't want to deal with, one of which is module bundlers, which are tools like webpack and vete that take all of your JavaScript CSS and HTML and package it in a way that can actually work in a browser. They might also provide a linter, like ESLint, to warn you when your code doesn't follow the proper style guidelines. Oh, and I almost forgot, you are definitely going to need a database to build a full-stack web application, because you need somewhere to store your data, like data about your users, but in order to get that data, you'll need to give users a way to log in via a process called user authentication. Now, before you deploy your code, you'll need to test it with a web server. There are tools like Ingenax and Apache. You create an HTTP server, but your framework will likely do this for you by serving the files on localhost, which makes your own IP address behave like a remote web server. When it comes time to deploy, you'll likely use a big cloud provider like AWS. Most apps are containerized with Docker, making them easy to scale up and down based on the amount of traffic that they receive. There are many tools out there that function as a platform as a service to manage this infrastructure for you in exchange for your money. Or, if you don't want to get locked in with a giant tech corporation, you might host your app on a decentralized blockchain with Web3. And that's about 1% of what you'll need to know to call yourself a full-stack web developer. If that seems overwhelming, don't worry too much. Almost nobody knows what the hell they're doing, and we all just use Google to figure things out on the fly. Congratulations, you just passed Web Development 101. Thanks for watching, and I will see you in the next one.", "course_id": "undefined"}, {"_id": "f37c3ddd-5730-446f-9c2a-7c8cd50e5174", "title": "Lecture 1", "description": "Uploaded lecture for course undefined", "video": "/uploads/f37c3ddd-5730-446f-9c2a-7c8cd50e5174.mp4", "transcript": " Maybe you're thinking about having your first one made, or maybe you just need a new better one. In any case, you should know at least some of the basics about web design. And don't worry, it will only take 3 minutes. First of all, let's face it, the website is the core of your online marketing activities. If you look at all the marketing channels and techniques, what they actually do is bring visitors through your website. And the main purpose of a website is turning these visitors into customers. In marketing terms, this is called conversion. A bad website will basically cause you to waste money on other marketing methods, because you don't need more visitors if you can't turn them into customers. So the better your website is, the more visitors are converted into your customers. And it doesn't really matter whether you sell consumer products online, provide local services, or build houses. Many people in the industry call themselves web designers, but they really are just a bunch of geeks with some basic coding knowledge. Of course, without much planning, they will pretty quickly create a website for you with lots of information, photos, contacts, but the question is, is that the way to turn the visitors into your customers? Is that what you need? And the answer is simple. No, what you have to do is look for someone serious about web design. Well, that's where we come in. This is how we make websites by following the 7 phase web design process. Phase 1. Analysis The first step is always about information gathering, identifying things like the website purpose, goals, and target audience. Phase 2. Planning A planning includes a definition of the site map, structure, and technologies that we're about to use. Phase 3. Not only do we focus on wireframe models and the visual style in this stage, but also on the usability of the user interface for the best possible user experience. Phase 4. Content A very important part of the process is choosing the right text, photos, or videos. All optimized not only for your visitors, but also for search engines. Phase 5. Development Here we actually create the website using the HyperText Markup Language and Cast Steeding Style Sheets with some help from databases and other technologies as well. If needed, our websites can be made accessible to mobile devices too. Phase 6. Testing We test all the technical features, like code and scripts, compatibility with major browsers, but we also ask ourselves if the website really fulfills its purpose. Phase 7. Deployment After we launch the site, our job is definitely not done yet. We always monitor what's happening after the start, enabling us to fix any possible deficiencies. And, if you want, we can also manage the future maintenance and updates for you. As you have just seen, web design is a very complex process, but we believe this is how websites should be done. And our customers agree. And if you share our passion for high quality websites, let's get in touch. We'll be happy to help you with what we do best.", "course_id": "undefined"}, {"_id": "7401ad60-d6d3-4247-b825-04201cf4de61", "title": "Lecture 1", "description": "Uploaded lecture for course undefined", "video": "/uploads/7401ad60-d6d3-4247-b825-04201cf4de61.mp4", "transcript": " Maybe you're thinking about having your first one made, or maybe you just need a new better one. In any case, you should know at least some of the basics about web design. And don't worry, it will only take 3 minutes. First of all, let's face it, the website is the core of your online marketing activities. If you look at all the marketing channels and techniques, what they actually do is bring visitors through your website. And the main purpose of a website is turning these visitors into customers. In marketing terms, this is called conversion. A bad website will basically cause you to waste money on other marketing methods, because you don't need more visitors if you can't turn them into customers. So the better your website is, the more visitors are converted into your customers. And it doesn't really matter whether you sell consumer products online, provide local services, or build houses. Many people in the industry call themselves web designers, but they really are just a bunch of geeks with some basic coding knowledge. Of course, without much planning, they will pretty quickly create a website for you with lots of information, photos, contacts, but the question is, is that the way to turn the visitors into your customers? Is that what you need? And the answer is simple. No, what you have to do is look for someone serious about web design. Well, that's where we come in. This is how we make websites by following the 7 phase web design process. Phase 1. Analysis The first step is always about information gathering, identifying things like the website purpose, goals, and target audience. Phase 2. Planning A planning includes a definition of the site map, structure, and technologies that we're about to use. Phase 3. Not only do we focus on wireframe models and the visual style in this stage, but also on the usability of the user interface for the best possible user experience. Phase 4. Content A very important part of the process is choosing the right text, photos, or videos. All optimized not only for your visitors, but also for search engines. Phase 5. Development Here we actually create the website using the HyperText Markup Language and Cast Steeding Style Sheets with some help from databases and other technologies as well. If needed, our websites can be made accessible to mobile devices too. Phase 6. Testing We test all the technical features, like code and scripts, compatibility with major browsers, but we also ask ourselves if the website really fulfills its purpose. Phase 7. Deployment After we launch the site, our job is definitely not done yet. We always monitor what's happening after the start, enabling us to fix any possible deficiencies. And, if you want, we can also manage the future maintenance and updates for you. As you have just seen, web design is a very complex process, but we believe this is how websites should be done. And our customers agree. And if you share our passion for high quality websites, let's get in touch. We'll be happy to help you with what we do best.", "course_id": "undefined"}, {"_id": "40a6231e-ea25-4146-b207-40dba9d85956", "title": "Lecture 1", "description": "Uploaded lecture for course undefined", "video": "/uploads/40a6231e-ea25-4146-b207-40dba9d85956.mp4", "transcript": " Web development is the best job in the world. You build on a platform with nearly 5 billion daily active users, all connected together like the neurons of a global super intelligent brain, a system that can cure disease, eliminate poverty, advance science, and stuff like that. But mostly it's used to share memes, create pair of social relationships, amplify drama, and most importantly, make tons and tons of money. If you want to get into it, you're going to need to know some stuff, like a lot of stuff. In web development 101, we'll take a look at 101 different concepts that you'll need to know when building full-stack web apps. This is the internet. It's a network of billions of machines connected together. What are you right to it like mail? No, a lot of people use it and communicate. I guess they can communicate with NBC, writers, and producers, Allison. Can you explain what internet is? It was officially born on January 1st, 1983, thanks to the establishment of the internet protocol suite, which standardize the way these computers communicate. The internet protocol is used to identify different computers on the network by assigning each one of them a unique IP address. These computers can then send data back and forth with the transmission control protocol. It breaks data into a bunch of small packets, kind of like puzzle pieces, then sends them through a bunch of physical components like fiber optic cables and modems before they're put back together by the receiving computer. You can think of the internet as hardware, but the internet is not the same thing as the web. The worldwide web is like software that sits on top of the internet, where people can access web pages with the hypertext transfer protocol. What's special about it is that it gives every page of content a uniform resource locator or URL. Humans typically use a tool called a web browser to access a URL where it can be rendered visually on their screen. The browser is called the client because it's consuming information, but on the other end of that URL there's another computer called a server. It received an HTTP request from the client, then sent a response containing the web page content. These are called HTTP messages, but more on that later. What's interesting is that every web page has a unique domain name, like fireship.io or example.com. A domain name can be registered by anyone via a registrar who's accredited by ICANN, a nonprofit responsible for overseeing namespaces on the internet. When you navigate to a domain in a browser, it gets routed through the domain name system that maps these names to an actual IP address on a server somewhere. DNS is like the phone book of the internet. Now, when you look at a web page, the actual content you see is represented by hypertext markup language. Most browsers have dev tools where you can inspect the structure of the HTML at any time. To build your own web page, you'll want a text editor like VS Code. An HTML document is just a collection of elements where an element is an opening and closing tag with some content in the middle, like a paragraph and heading. It also has elements that handle user input, like the select and input elements, which are used to build forms. In addition, elements can have one or more attributes to change their behavior. For example, an input can have a type like text or number, which the browser will render differently to collect the appropriate value. But the element that puts the hypertext in HTML is the A tag or anchor. It's a link that allows one page to navigate to a different page based on its URL. These elements are nested together in a hierarchy to form the document object model or DOM. From the root element, a web page is split into two parts. The head contains invisible content like metadata and a title. Then we have the body for the main content that the end user actually sees. The reason we wrap everything in tags is to give browsers and bots hints about the semantic meaning of the web page. This allows search engines to display results properly and also helps with accessibility for devices like screen readers that allow anybody regardless of disability to enjoy the content. My computer reads me the text. Bro, smash that like button and subscribe. One of the most common elements you'll come across is div or division to define a section of the web page. On its own, a div might not seem to do anything and currently produces this plain black and white website. That begs the question, how do we make this website look cool? The second language you'll need to learn as a web developer is cascading style sheets or CSS, which allows you to change the appearance of the HTML elements. One way to accomplish that is with an inline style, using the style attribute on an element. The style itself contains a collection of properties and values that change the appearance of the element, like we might make the background color black and the text color red. What we've created here is an inline style that will only be applied to this one element. However, CSS cascades, which means it can be applied to multiple elements at the same time, providing better code reusability. Another option is to move our code into a style tag, but to make the code work, we'll first need to define a selector so it knows which elements to target. A selector, for example, can target all of the paragraph elements on the page, but that's too broad. We can be more granular by defining a class. That style can then be applied to one or more elements with the class attribute. What's interesting though, is that we now have classes that apply different styles to the same element. CSS contains a bunch of specificity rules that determine which styles are relevant to an element in a way that's self evident and elegant, like a benevolent elephant. Most often though, we don't use style tags, but instead use an external style sheet, which is linked to the web page in the head of the document. When it comes to CSS, by far the most difficult thing to learn is layout and positioning. Think of every element like a box. The outside of that box is wrapped with padding, border, and margin. The boxes then take up space on the page from top to bottom. Some elements like heading have a display of block by default, which means they take up all available horizontal space. Other elements like image are displayed in line, which means they can line up horizontally side by side. The problem is that the default position is usually not desirable. It can be changed by customizing the position property on an element. Relative positioning allows an element to move a certain number of pixels from its normal position. Absolute positioning is similar, but the position values are relative to its nearest ancestor. And then we have fixed positioning, which will keep an element on the screen, even as the user scrolls away from it, because it's fixed to the entire viewport. Changing the position of an element is one thing, but one of the biggest challenges web developers face is creating responsive layouts. Users can access your web page from all kinds of different screens, and it should look good on all of them. CSS provides a bunch of different tools to help make this happen. One of which is media queries. A media query allows you to get information about the device that's rendering the web page, and apply different styles accordingly. But more importantly, it provides layout tools like flexbox. Applying display flex allows the parent to control the flow of the children to easily create rows and columns. For more complex layouts, display grid can be used to control multiple rows and columns at the same time. Now CSS is usually not considered a Turing Complete Programming Language on its own. However, it does have mechanisms like Calc to perform mathematical operations, and custom properties, which are like variables that you can reuse in multiple places. Vanilla CSS is rarely enough, though, and many developers choose to extend it with tools like SAS that add additional programmatic features on top of it, and that brings us to the third language you'll need to know as a web developer, JavaScript. Technically, you don't need JavaScript to build a website. However, most developers choose to use it to make the user interface more interactive. To run JavaScript code on a web page, open up a script tag, then write some JavaScript code inside of it. The browser interprets the HTML from top to bottom, and runs this code when it encounters it in the DOM. In most cases, JavaScript is written in a separate file, then referenced as the source on the script tag. Usually, it's preferred that this code runs after the DOM content has loaded, which can be accomplished with the defer attribute. JS is a big complicated programming language, which is more formally known as ECMO script and is standardized in all major browsers. There are several different ways to declare a variable, a variable that might be reassigned in the future uses the like keyword, while a variable that can't be reassigned uses const. It's a dynamically typed language, which means no type annotations are necessary. That's not always ideal, so many developers choose TypeScript as an alternative to add static typing on top of JavaScript. Now, one of the most common reasons you would use JavaScript in the first place is to handle events. Whenever the user does something on a web page, the browser emits an event that you can listen to. Like a click, mouse move, form input change, and so on. We can tap into these events using browser APIs like document, which in this case provides a method called query selector that allows us to grab an element with a CSS selector. Once we have that element set as a variable, we can then assign an event listener to it. An event listener is a function that will be called or re-executed anytime the button is clicked. The language has a variety of built-in data structures like an array to represent a collection of values, but the most fundamental data structure is the object. Also commonly called a dictionary or hash map. Anything that's not a primitive type like a string or number inherits its base functionality from the object class. It relies on a technique called prototypal inheritance, where an object can be cloned multiple times to create a chain of ancestors where the child inherits the properties and methods of its ancestors. This is different from class-based inheritance, which is kind of confusing because JavaScript also supports classes. However, these classes are just syntactic sugar for prototypal inheritance, but now we're getting a little too low level. Most developers don't ever want to have to touch the word prototype, so what we do instead is use a front-end framework, like React, View, Spelt, Angular, and so on. All of these frameworks do the same thing in a slightly different way, which is represent the UI as a tree of components. A component can encapsulate HTML, CSS, and JavaScript into a format that looks like its own custom HTML element. Most importantly, they produce declarative code that describes exactly what the UI does, and that's much easier to work with than imperative code that you would normally get with just plain vanilla JavaScript. At this point, we've taken a look at the front-end stack, but now we need to switch gears to the back end, starting with Node.js, which is a server-side runtime based on JavaScript. You can run server-side code for web applications in all kinds of different languages, but Node is the most popular because it relies on the same language as the browser. It's also based on the same V8 engine that powers the chromium browser to run code in a single threaded, non-blocking event loop. This allows Node to handle many simultaneous connections quickly and efficiently. In addition, it allows developers to share work remotely thanks to the Node Package Manager. A package is also called a module, which is just a file that contains some code with an export statement so it can be used in another file. The file can consume a module with an import statement, but now we need to think about how to deliver the actual website from the server to the client. The classic option is server-side rendering. In this approach, the client will make a Git request for a certain URL. Every request has an HTTP method, and Git means you want to retrieve data from a server, as opposed to methods like Post and Patch, where the intent is to modify data. The server receives the request, and then generates all the HTML on the server, and sends it back to the client as a response. The response contains a status code, like 200 for success, or levels 4 and 504 errors. For example, if the webpage doesn't exist, the server will return a 404 status code, which you've likely seen before as a web user. SSR is extremely popular, but in some cases, it may not be fast enough. Another approach is the single page application. With this approach, the server only renders a shell for the root URL. Then JavaScript handles the rendering for all other pages on the website. The HTML is generated almost entirely client-side in the browser. Making the website feel more like a native iOS or Android app. When the app needs more data, it still makes an HTTP request, but only requests a minimal amount of data as JSON, which is called a data interchange format that can be understood by any programming language. This can result in a great user experience. However, it can be very difficult for bots, like search engines, and social media link previews, to understand content on the page. This led to another rendering strategy called static site generation. In this case, every web page on the site is uploaded to a server in advance, allowing bots to get the information they need. A front-end JavaScript framework usually takes over to hydrate the HTML, to make it fully interactive, and behave like a single page application. Performance is extremely important, and you'll want to use tools like Lighthouse to optimize metrics like first-contentful paint and time to interactive. Now, to implement one of these patterns, most developers will use a full-stack framework, like next JS, Ruby on Rails, Larvel, and so on. They abstract away many of the more tedious things developers don't want to deal with, one of which is module bundlers, which are tools like webpack and vete that take all of your JavaScript CSS and HTML and package it in a way that can actually work in a browser. They might also provide a linter, like ESLint, to warn you when your code doesn't follow the proper style guidelines. Oh, and I almost forgot, you are definitely going to need a database to build a full-stack web application, because you need somewhere to store your data, like data about your users, but in order to get that data, you'll need to give users a way to log in via a process called user authentication. Now, before you deploy your code, you'll need to test it with a web server. There are tools like Ingenax and Apache. You create an HTTP server, but your framework will likely do this for you by serving the files on localhost, which makes your own IP address behave like a remote web server. When it comes time to deploy, you'll likely use a big cloud provider like AWS. Most apps are containerized with Docker, making them easy to scale up and down based on the amount of traffic that they receive. There are many tools out there that function as a platform as a service to manage this infrastructure for you in exchange for your money. Or, if you don't want to get locked in with a giant tech corporation, you might host your app on a decentralized blockchain with Web3. And that's about 1% of what you'll need to know to call yourself a full-stack web developer. If that seems overwhelming, don't worry too much. Almost nobody knows what the hell they're doing, and we all just use Google to figure things out on the fly. Congratulations, you just passed Web Development 101. Thanks for watching, and I will see you in the next one.", "course_id": "undefined"}, {"_id": "5f94138b-5be0-4e42-9e10-69e76e87294f", "title": "Lecture 1", "description": "Uploaded lecture for course undefined", "video": "/uploads/5f94138b-5be0-4e42-9e10-69e76e87294f.mp4", "transcript": " Maybe you're thinking about having your first one made, or maybe you just need a new better one. In any case, you should know at least some of the basics about web design. And don't worry, it will only take 3 minutes. First of all, let's face it, the website is the core of your online marketing activities. If you look at all the marketing channels and techniques, what they actually do is bring visitors through your website. And the main purpose of a website is turning these visitors into customers. In marketing terms, this is called conversion. A bad website will basically cause you to waste money on other marketing methods, because you don't need more visitors if you can't turn them into customers. So the better your website is, the more visitors are converted into your customers. And it doesn't really matter whether you sell consumer products online, provide local services, or build houses. Many people in the industry call themselves web designers, but they really are just a bunch of geeks with some basic coding knowledge. Of course, without much planning, they will pretty quickly create a website for you with lots of information, photos, contacts, but the question is, is that the way to turn the visitors into your customers? Is that what you need? And the answer is simple. No, what you have to do is look for someone serious about web design. Well, that's where we come in. This is how we make websites by following the 7 phase web design process. Phase 1. Analysis The first step is always about information gathering, identifying things like the website purpose, goals, and target audience. Phase 2. Planning A planning includes a definition of the site map, structure, and technologies that we're about to use. Phase 3. Not only do we focus on wireframe models and the visual style in this stage, but also on the usability of the user interface for the best possible user experience. Phase 4. Content A very important part of the process is choosing the right text, photos, or videos. All optimized not only for your visitors, but also for search engines. Phase 5. Development Here we actually create the website using the HyperText Markup Language and Cast Steeding Style Sheets with some help from databases and other technologies as well. If needed, our websites can be made accessible to mobile devices too. Phase 6. Testing We test all the technical features, like code and scripts, compatibility with major browsers, but we also ask ourselves if the website really fulfills its purpose. Phase 7. Deployment After we launch the site, our job is definitely not done yet. We always monitor what's happening after the start, enabling us to fix any possible deficiencies. And, if you want, we can also manage the future maintenance and updates for you. As you have just seen, web design is a very complex process, but we believe this is how websites should be done. And our customers agree. And if you share our passion for high quality websites, let's get in touch. We'll be happy to help you with what we do best.", "course_id": "undefined"}, {"_id": "66d366f3-4100-455e-b933-51784b03f5e8", "title": "Lecture 1", "description": "Uploaded lecture for course undefined", "video": "/uploads/66d366f3-4100-455e-b933-51784b03f5e8.mp4", "transcript": " Web development is the best job in the world. You build on a platform with nearly 5 billion daily active users, all connected together like the neurons of a global super intelligent brain, a system that can cure disease, eliminate poverty, advance science, and stuff like that. But mostly it's used to share memes, create pair of social relationships, amplify drama, and most importantly, make tons and tons of money. If you want to get into it, you're going to need to know some stuff, like a lot of stuff. In web development 101, we'll take a look at 101 different concepts that you'll need to know when building full-stack web apps. This is the internet. It's a network of billions of machines connected together. What are you right to it like mail? No, a lot of people use it and communicate. I guess they can communicate with NBC, writers, and producers, Allison. Can you explain what internet is? It was officially born on January 1st, 1983, thanks to the establishment of the internet protocol suite, which standardize the way these computers communicate. The internet protocol is used to identify different computers on the network by assigning each one of them a unique IP address. These computers can then send data back and forth with the transmission control protocol. It breaks data into a bunch of small packets, kind of like puzzle pieces, then sends them through a bunch of physical components like fiber optic cables and modems before they're put back together by the receiving computer. You can think of the internet as hardware, but the internet is not the same thing as the web. The worldwide web is like software that sits on top of the internet, where people can access web pages with the hypertext transfer protocol. What's special about it is that it gives every page of content a uniform resource locator or URL. Humans typically use a tool called a web browser to access a URL where it can be rendered visually on their screen. The browser is called the client because it's consuming information, but on the other end of that URL there's another computer called a server. It received an HTTP request from the client, then sent a response containing the web page content. These are called HTTP messages, but more on that later. What's interesting is that every web page has a unique domain name, like fireship.io or example.com. A domain name can be registered by anyone via a registrar who's accredited by ICANN, a nonprofit responsible for overseeing namespaces on the internet. When you navigate to a domain in a browser, it gets routed through the domain name system that maps these names to an actual IP address on a server somewhere. DNS is like the phone book of the internet. Now, when you look at a web page, the actual content you see is represented by hypertext markup language. Most browsers have dev tools where you can inspect the structure of the HTML at any time. To build your own web page, you'll want a text editor like VS Code. An HTML document is just a collection of elements where an element is an opening and closing tag with some content in the middle, like a paragraph and heading. It also has elements that handle user input, like the select and input elements, which are used to build forms. In addition, elements can have one or more attributes to change their behavior. For example, an input can have a type like text or number, which the browser will render differently to collect the appropriate value. But the element that puts the hypertext in HTML is the A tag or anchor. It's a link that allows one page to navigate to a different page based on its URL. These elements are nested together in a hierarchy to form the document object model or DOM. From the root element, a web page is split into two parts. The head contains invisible content like metadata and a title. Then we have the body for the main content that the end user actually sees. The reason we wrap everything in tags is to give browsers and bots hints about the semantic meaning of the web page. This allows search engines to display results properly and also helps with accessibility for devices like screen readers that allow anybody regardless of disability to enjoy the content. My computer reads me the text. Bro, smash that like button and subscribe. One of the most common elements you'll come across is div or division to define a section of the web page. On its own, a div might not seem to do anything and currently produces this plain black and white website. That begs the question, how do we make this website look cool? The second language you'll need to learn as a web developer is cascading style sheets or CSS, which allows you to change the appearance of the HTML elements. One way to accomplish that is with an inline style, using the style attribute on an element. The style itself contains a collection of properties and values that change the appearance of the element, like we might make the background color black and the text color red. What we've created here is an inline style that will only be applied to this one element. However, CSS cascades, which means it can be applied to multiple elements at the same time, providing better code reusability. Another option is to move our code into a style tag, but to make the code work, we'll first need to define a selector so it knows which elements to target. A selector, for example, can target all of the paragraph elements on the page, but that's too broad. We can be more granular by defining a class. That style can then be applied to one or more elements with the class attribute. What's interesting though, is that we now have classes that apply different styles to the same element. CSS contains a bunch of specificity rules that determine which styles are relevant to an element in a way that's self evident and elegant, like a benevolent elephant. Most often though, we don't use style tags, but instead use an external style sheet, which is linked to the web page in the head of the document. When it comes to CSS, by far the most difficult thing to learn is layout and positioning. Think of every element like a box. The outside of that box is wrapped with padding, border, and margin. The boxes then take up space on the page from top to bottom. Some elements like heading have a display of block by default, which means they take up all available horizontal space. Other elements like image are displayed in line, which means they can line up horizontally side by side. The problem is that the default position is usually not desirable. It can be changed by customizing the position property on an element. Relative positioning allows an element to move a certain number of pixels from its normal position. Absolute positioning is similar, but the position values are relative to its nearest ancestor. And then we have fixed positioning, which will keep an element on the screen, even as the user scrolls away from it, because it's fixed to the entire viewport. Changing the position of an element is one thing, but one of the biggest challenges web developers face is creating responsive layouts. Users can access your web page from all kinds of different screens, and it should look good on all of them. CSS provides a bunch of different tools to help make this happen. One of which is media queries. A media query allows you to get information about the device that's rendering the web page, and apply different styles accordingly. But more importantly, it provides layout tools like flexbox. Applying display flex allows the parent to control the flow of the children to easily create rows and columns. For more complex layouts, display grid can be used to control multiple rows and columns at the same time. Now CSS is usually not considered a Turing Complete Programming Language on its own. However, it does have mechanisms like Calc to perform mathematical operations, and custom properties, which are like variables that you can reuse in multiple places. Vanilla CSS is rarely enough, though, and many developers choose to extend it with tools like SAS that add additional programmatic features on top of it, and that brings us to the third language you'll need to know as a web developer, JavaScript. Technically, you don't need JavaScript to build a website. However, most developers choose to use it to make the user interface more interactive. To run JavaScript code on a web page, open up a script tag, then write some JavaScript code inside of it. The browser interprets the HTML from top to bottom, and runs this code when it encounters it in the DOM. In most cases, JavaScript is written in a separate file, then referenced as the source on the script tag. Usually, it's preferred that this code runs after the DOM content has loaded, which can be accomplished with the defer attribute. JS is a big complicated programming language, which is more formally known as ECMO script and is standardized in all major browsers. There are several different ways to declare a variable, a variable that might be reassigned in the future uses the like keyword, while a variable that can't be reassigned uses const. It's a dynamically typed language, which means no type annotations are necessary. That's not always ideal, so many developers choose TypeScript as an alternative to add static typing on top of JavaScript. Now, one of the most common reasons you would use JavaScript in the first place is to handle events. Whenever the user does something on a web page, the browser emits an event that you can listen to. Like a click, mouse move, form input change, and so on. We can tap into these events using browser APIs like document, which in this case provides a method called query selector that allows us to grab an element with a CSS selector. Once we have that element set as a variable, we can then assign an event listener to it. An event listener is a function that will be called or re-executed anytime the button is clicked. The language has a variety of built-in data structures like an array to represent a collection of values, but the most fundamental data structure is the object. Also commonly called a dictionary or hash map. Anything that's not a primitive type like a string or number inherits its base functionality from the object class. It relies on a technique called prototypal inheritance, where an object can be cloned multiple times to create a chain of ancestors where the child inherits the properties and methods of its ancestors. This is different from class-based inheritance, which is kind of confusing because JavaScript also supports classes. However, these classes are just syntactic sugar for prototypal inheritance, but now we're getting a little too low level. Most developers don't ever want to have to touch the word prototype, so what we do instead is use a front-end framework, like React, View, Spelt, Angular, and so on. All of these frameworks do the same thing in a slightly different way, which is represent the UI as a tree of components. A component can encapsulate HTML, CSS, and JavaScript into a format that looks like its own custom HTML element. Most importantly, they produce declarative code that describes exactly what the UI does, and that's much easier to work with than imperative code that you would normally get with just plain vanilla JavaScript. At this point, we've taken a look at the front-end stack, but now we need to switch gears to the back end, starting with Node.js, which is a server-side runtime based on JavaScript. You can run server-side code for web applications in all kinds of different languages, but Node is the most popular because it relies on the same language as the browser. It's also based on the same V8 engine that powers the chromium browser to run code in a single threaded, non-blocking event loop. This allows Node to handle many simultaneous connections quickly and efficiently. In addition, it allows developers to share work remotely thanks to the Node Package Manager. A package is also called a module, which is just a file that contains some code with an export statement so it can be used in another file. The file can consume a module with an import statement, but now we need to think about how to deliver the actual website from the server to the client. The classic option is server-side rendering. In this approach, the client will make a Git request for a certain URL. Every request has an HTTP method, and Git means you want to retrieve data from a server, as opposed to methods like Post and Patch, where the intent is to modify data. The server receives the request, and then generates all the HTML on the server, and sends it back to the client as a response. The response contains a status code, like 200 for success, or levels 4 and 504 errors. For example, if the webpage doesn't exist, the server will return a 404 status code, which you've likely seen before as a web user. SSR is extremely popular, but in some cases, it may not be fast enough. Another approach is the single page application. With this approach, the server only renders a shell for the root URL. Then JavaScript handles the rendering for all other pages on the website. The HTML is generated almost entirely client-side in the browser. Making the website feel more like a native iOS or Android app. When the app needs more data, it still makes an HTTP request, but only requests a minimal amount of data as JSON, which is called a data interchange format that can be understood by any programming language. This can result in a great user experience. However, it can be very difficult for bots, like search engines, and social media link previews, to understand content on the page. This led to another rendering strategy called static site generation. In this case, every web page on the site is uploaded to a server in advance, allowing bots to get the information they need. A front-end JavaScript framework usually takes over to hydrate the HTML, to make it fully interactive, and behave like a single page application. Performance is extremely important, and you'll want to use tools like Lighthouse to optimize metrics like first-contentful paint and time to interactive. Now, to implement one of these patterns, most developers will use a full-stack framework, like next JS, Ruby on Rails, Larvel, and so on. They abstract away many of the more tedious things developers don't want to deal with, one of which is module bundlers, which are tools like webpack and vete that take all of your JavaScript CSS and HTML and package it in a way that can actually work in a browser. They might also provide a linter, like ESLint, to warn you when your code doesn't follow the proper style guidelines. Oh, and I almost forgot, you are definitely going to need a database to build a full-stack web application, because you need somewhere to store your data, like data about your users, but in order to get that data, you'll need to give users a way to log in via a process called user authentication. Now, before you deploy your code, you'll need to test it with a web server. There are tools like Ingenax and Apache. You create an HTTP server, but your framework will likely do this for you by serving the files on localhost, which makes your own IP address behave like a remote web server. When it comes time to deploy, you'll likely use a big cloud provider like AWS. Most apps are containerized with Docker, making them easy to scale up and down based on the amount of traffic that they receive. There are many tools out there that function as a platform as a service to manage this infrastructure for you in exchange for your money. Or, if you don't want to get locked in with a giant tech corporation, you might host your app on a decentralized blockchain with Web3. And that's about 1% of what you'll need to know to call yourself a full-stack web developer. If that seems overwhelming, don't worry too much. Almost nobody knows what the hell they're doing, and we all just use Google to figure things out on the fly. Congratulations, you just passed Web Development 101. Thanks for watching, and I will see you in the next one.", "course_id": "undefined"}, {"_id": "e089c256-9735-4150-8233-0331bf3ff9e7", "title": "Lecture 2", "description": "Uploaded lecture for course undefined", "video": "/uploads/e089c256-9735-4150-8233-0331bf3ff9e7.mp4", "transcript": " Maybe you're thinking about having your first one made, or maybe you just need a new better one. In any case, you should know at least some of the basics about web design. And don't worry, it will only take 3 minutes. First of all, let's face it, the website is the core of your online marketing activities. If you look at all the marketing channels and techniques, what they actually do is bring visitors through your website. And the main purpose of a website is turning these visitors into customers. In marketing terms, this is called conversion. A bad website will basically cause you to waste money on other marketing methods, because you don't need more visitors if you can't turn them into customers. So the better your website is, the more visitors are converted into your customers. And it doesn't really matter whether you sell consumer products online, provide local services, or build houses. Many people in the industry call themselves web designers, but they really are just a bunch of geeks with some basic coding knowledge. Of course, without much planning, they will pretty quickly create a website for you with lots of information, photos, contacts, but the question is, is that the way to turn the visitors into your customers? Is that what you need? And the answer is simple. No, what you have to do is look for someone serious about web design. Well, that's where we come in. This is how we make websites by following the 7 phase web design process. Phase 1. Analysis The first step is always about information gathering, identifying things like the website purpose, goals, and target audience. Phase 2. Planning A planning includes a definition of the site map, structure, and technologies that we're about to use. Phase 3. Not only do we focus on wireframe models and the visual style in this stage, but also on the usability of the user interface for the best possible user experience. Phase 4. Content A very important part of the process is choosing the right text, photos, or videos. All optimized not only for your visitors, but also for search engines. Phase 5. Development Here we actually create the website using the HyperText Markup Language and Cast Steeding Style Sheets with some help from databases and other technologies as well. If needed, our websites can be made accessible to mobile devices too. Phase 6. Testing We test all the technical features, like code and scripts, compatibility with major browsers, but we also ask ourselves if the website really fulfills its purpose. Phase 7. Deployment After we launch the site, our job is definitely not done yet. We always monitor what's happening after the start, enabling us to fix any possible deficiencies. And, if you want, we can also manage the future maintenance and updates for you. As you have just seen, web design is a very complex process, but we believe this is how websites should be done. And our customers agree. And if you share our passion for high quality websites, let's get in touch. We'll be happy to help you with what we do best.", "course_id": "undefined"}]}